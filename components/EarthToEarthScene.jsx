/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import {
  Box,
  Line,
  OrbitControls,
  useAnimations,
  useGLTF,
} from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useControls } from "leva";
import React, { useEffect, useMemo, useRef } from "react";
import { AnimationMixer, Quaternion, Vector3 } from "three";
import { blenderJsonToCatmullCurve } from "../helpers/blenderJsonToCatmullCurve";
import earthToEarthJson from "../public/models/earth2earth.json";

const earthToEarthUrl = "/models/earth2earth.glb";

let animationProgress = 0;

const _cameraPosition = new Vector3();
const _cameraQuaternion = new Quaternion();

export function EarthToEarthScene(props) {
  const cameraPlaceholderRef = useRef(null);
  const group = useRef(null);

  const { camera, gl } = useThree();

  const {
    debugCameraAnimationProgress,
    orbitControls,
    activeDebugCameraAnimationProgress,
  } = useControls({
    debugCameraAnimationProgress: {
      value: 0,
      min: 0,
      max: 0.9,
      step: 0.00001,
    },
    activeDebugCameraAnimationProgress: false,
    orbitControls: true,
  });

  const { scene, animations, cameras } = useGLTF(earthToEarthUrl);

  const animationMixer = useMemo(() => new AnimationMixer(scene), [scene]);
  const cameraPathCurve = useMemo(
    () => blenderJsonToCatmullCurve(earthToEarthJson),
    []
  );

  const _animations = useAnimations(animations);

  const { actions, clips, names: animationNames } = _animations;

  // play CameraAction in clips
  const cameraActionIndex = animationNames.indexOf("CameraAction.001");
  const cameraActionClip = clips[cameraActionIndex];

  const sceneCamera = cameras[0];

  useEffect(() => {
    // switch camera to the first camera in the scene
    camera.copy(sceneCamera);
  }, [camera, sceneCamera]);

  // play animation
  useEffect(() => {
    animationMixer.clipAction(cameraActionClip).play();
  }, [actions, animationMixer, animationNames, cameraActionClip, clips]);

  useFrame((state, delta) => {
    _cameraPosition.copy(sceneCamera.position);
    _cameraQuaternion.copy(sceneCamera.quaternion);

    if (!orbitControls) {
      state.camera.position.copy(_cameraPosition);
      state.camera.quaternion.copy(_cameraQuaternion);
    } else if (cameraPlaceholderRef.current) {
      // @ts-ignore
      cameraPlaceholderRef.current.position.copy(_cameraPosition);
    }

    if (activeDebugCameraAnimationProgress) {
      animationProgress = debugCameraAnimationProgress;
    } else {
      // update animation progress when it reaches the end, reset to 0
      animationProgress += delta * 0.1;
      animationProgress = animationProgress % 1;
    }

    animationMixer.setTime(animationProgress * cameraActionClip.duration);

    // animationMixer.update(delta);
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={scene} />
      <Box ref={cameraPlaceholderRef} scale={2} visible={orbitControls}>
        <meshStandardMaterial color={"blue"} wireframe />
      </Box>
      <Line
        points={cameraPathCurve.getPoints(100)}
        renderOrder={100}
        color={"yellow"}
        depthTest={false}
      ></Line>
      <OrbitControls enabled={orbitControls} />
    </group>
  );
}

useGLTF.preload(earthToEarthUrl);
